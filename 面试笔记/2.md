## 基础系列文章
[掘金：神三元](https://juejin.im/user/430664257382462/posts)

## vue 的 template 编译，vue 的渲染机制
	
1.解析模版，生成AST语法树：
	使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理，参考 [浏览器-关键字：解析算法](https://juejin.im/post/6844904021308735502#heading-36)。
    涉及`静态节点优化`，设置 static 属性用于 diff 剪枝，静态节点就是一些不带变量的文本节点，不带 if 和 for 的节点。
	深度遍历 AST，标记静态节点以优化跳过比对，最后转为可执行的代码
2.AST会经过generate得到render函数，不同的节点生成方式也不一样，静态节点、指令节点、组件...
	render 生成虚拟 dom，最后 patch，diff，渲染 dom，静态节点可以在下次渲染时直接跳过
	

## ES module 和 commonjs 的区别：关键点：前者是值的引用，后者是值的拷贝。前者编译时输出接口，后者运行时加载。
	commonjs exports 默认指向 module.exports 的内存空间
  ES module：值引用，会改变原始值
  node commonjs：值拷贝，运行时加载并缓存，函数调用不会改变原始值，所以使用时最好赋一个变量来 require ，`const test = require('./a.js');`，避免内存指向改动后不能及时更新的问题
    
  [webpack 的动态加载](https://juejin.im/post/6844903888319954952)：
  IIFE 主函数将转化后的入口文件以及路径作为 modules 对象传入，返回 webpack_require 执行函数，这个函数的作用是执行入口文件并 exports 出来
  此时源代码已经被转换，import 转成了 webpack_require__.e，该函数会去检查一个已加载在内存中的installedChunks 缓存，模块在里面就取出来，没有就发起一个网络 jsonp 请求（请求本地），然后加载异步模块，同时加入installedChunks 队列并标记缓存，到这里仅仅是加载完成，接下来应该是执行后续的回调，或者是 resolve。
  回调的触发涉及一个 webpackJsonpCallback
    
    
  扩展：
  splitChunkPlugin 本质都是代码分割，webpack_require 模拟了一个能在浏览器执行的 require 语句，类似 nodejs
  组件动态加载/懒加载 React.lazy(import)+React.Suspense(类 loading 方案) 搭配使用，更进一步还能手动控制显隐
    
  chainWebpack：链式配置，比如修改别名 alias，配置图片压缩等等
	首屏不能按需加载，图表库、视频编解码库这些不是第一级的可以按需加载，加载一次后便会缓存下来


## 从输入到渲染的整个流程

```
- 原页面数据清理 beforeunload
...
- DNS prefetch：这是已经下载的 html 文本进行其他资源的预解析，比如 link 外部文件
- 请求协议是 https 时，建立 tls
- 建树期间遇到外部脚本 async/defer 的处理

- 注意点：
- 1.css 解析和 dom 解析是并行的，这意味着两者解析不会互相阻塞，css 解析会阻塞 dom 渲染和 js 执行
- 什么会引起页面加载的阻塞
- GUI渲染线程与JS引擎线程是互斥的，GUI 遇到 <script> 标签就会停止，js 引擎线程开始工作
```
## Event Loop


- 微任务 Promise.then、node 中的 process.nextTick 优先于微
- 异步任务进入 event table 并注册函数，完成后将回调放入 event queue
- iterator 创建一个指针对象，指向数据的起始位置，用 next 调用
- async 是将 Generator 和自动执行器包装在一个函数里
- async 的优缺点：`多个异步代码没有依赖性却使用 await 降低性能`
- Generator 是协程在 ES6 的实现，最大特点：暂停执行
- 协程的概念
- v2 nextTick 原理：在下次 DOM 更新结束之后执行延迟回调，即 UI render 之后，主要使用了宏/微任务（任意选择，看兼容，先微后宏，因为微优先级更高），根据执行环境分别尝试使用 Promise(微)，MutationObserver(微)，setImmediate(宏)，以上都没 setTimeout 替补。一次 tick 内执行多次 nextTick，都统一压进一个 callbacks 数组，在下一个 tick 遍历执行。
- tick 可以简单理解为一次 eventloop 的宏任务结束，或者 dom 渲染结束，下一轮开始或者空等待。

其中settimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行；
promise.then里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行；async函数表示函数里面可能会有异步方法，await后面跟一个表达式，async方法执行时，遇到await会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行


`解析 generator` 第一个 next 不用传参，为5；参数作为上一个 yield 的返回值...，next 是执行并返回本次 yield (执行)

```
function *foo(x) {
  let y = 2 * (yield (x + 1))
  let z = yield (y / 3)
  return (x + y + z)
}
let it = foo(5)
console.log(it.next())   // => {value: 6, done: false}
console.log(it.next(12)) // => {value: 8, done: false}
console.log(it.next(13)) // => {value: 42, done: true}
```
## [Vue 和 React 的区别](https://juejin.im/post/6844904170538041351#heading-4)

- 从大到小，从广到详，从思想、生态、语法、数据、通信、diff等角度总结
1. vue v-model 双向绑定，本质上是 input 事件和 value 的语法糖，可以使用 prop/event 自定义
   注意：双向绑定和 vuex 在严格模式下直接使用确实会有问题，会冲突；在严格模式中使用Vuex，当用户输入时，v-model会试图直接修改属性值，但这个修改不是在mutation中修改的，所以会抛出一个错误
   解决：在input中绑定value(vuex中的state)，然后监听input的change或者input事件，在事件回调中调用mutation修改state的值
2. react setState 伪异步，vue 依赖自动跟踪
3. react 更新渲染需要手动优化，fiber
	引申：diff 和 fiber
5. react jsx 和 vue render
6. 生态、上手难度


## Proxy 与 Object.defineProperty

- 拦截外界对该对象的访问，过滤和改写
- configurable: false 属性不可删除，该字段控制修改属性
- enumerable: false 定义对象的属性是否可以在 for...in 循环和 Object.keys() 中被枚举
- 在 writable: true 的情况下，赋值 value（数值，对象，函数 ...ary 等）：应用在 v2 的 array 监听
- [MDN proxy 资料](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy)

29. 引用类型怎么存储
```
- 同时存储在栈（stack）和堆（heap）中，占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体
```
30. 作用域链与执行上下文的区别

js 的执行分为：解释和执行两个阶段
解释阶段确定作用域，作用域是固定的；执行阶段创建执行上下文和 this，执行上下是会切换的

31. 闭包
```
- 调用和隐藏函数的私有变量
- 私有变量会留在内存中，闭包函数保留了其引用，所以变量对象不会被回收。
- DOM 引用 let dom = document.querySelect('.class'); dom=null
```

32. 事件和事件委托（捕获、冒泡）、事件循环

	1.DOMContentLoaded 监听 dom 挂载

	2.load 监听页面所有资源加载渲染完毕

33. MVC，MVVM 架构演变
```
- C：业务逻辑
- P: Presenter 中介，依旧是逻辑
- MVVM 与 MVP 非常相似：V 和 M 不发生联系，其他部分的通信都是双向的，VM 是个桥。
- MVVM 双向绑定：V 的变动，自动反映在 VM
- MVVM 的问题：执行效率，数据改变 UI 也会频繁更新，引发子组件更新，性能不是最优
- Reactjs 是一个单向数据流的库，状态驱动视图 MVC，不是 MVVM：State -> View -> New State -> New View
- React 全家桶是类似 MVP 架构：View 与 Model 不发生联系，都通过 Presenter 传递，View 非常薄，不部署任何业务逻辑，称为"被动视图"，而 Presenter非常厚，所有逻辑都部署在那里
- VM：ViewModel 是 View 和 Model 层的桥梁，数据会绑定到 viewModel 层并自动将数据渲染到页面中，视图变化的时候会通知 viewModel 层更新数据
- 库 library 和框架 framework 的区别：reactjs 库只是用来构建用户界面，框架则是一整套的解决方案；- 框架的特点：设计复用、控制反转，框架负责流程，提供一些插入代码的地方，根据需要取调用
- 本身 c，p，vm 的边界界定就十分模糊，不用钻牛角尖，核心其实就是每一层专注于每一层的任务。再次基础上的扩展以及如何对代码进行组织管理，是看需求来界定的，这也是框架架构模式不断发展的原因。
```

35. 触摸事件的响应顺序：ontouchstart，ontouchmove，ontouchend，onclick，涉及 300ms

36. 1px 像素问题：DPR 等于 2 的设备上，当设计稿中出现 1px 的像素时，css 像素实际应等于 0.5px
```
- css 像素 = 物理像素 / window.devicePixelRatio
```

38. 文件上传的二进制具体是怎么处理的
```
- 头信息：推荐 multipart/form-data，没必要做 application/x-www-form-urlencoded
- 数据拦截和加密
```

40. Computed 和 watch 的实现原理

- computed 本质是一个具备缓存的 watcher，依赖的属性发生变化就会更新视图，同步计算类似 mutation。
- watch 当需要在数据变化时执行异步操作时，这个方式是最有用的，默认只有 getter，deep 深度监听对象，immediate: true 初始化便立即执行

43. 项目的框架层次图，以及未来的迭代 ？

44. PV 和 UV 怎么统计，页面的行为监控，访问量过大怎么处理
```
性能监控，异常监控，基本在小公司，是没有实践基础的，可是在差不多的大厂中，他们会关注这个问题。
首先是性能监控，应该从这么几个维度来说：一个是http的方面，在后端log日志，流入kafka，然后在kafka消费数据，可以准确的监控到哪些接口有异常，异常率是多少
另一个方面，是前端的 Performance 的api，在用户的实时使用的过程中，就会产生数据，这样就能实现页面性能监控。
前端异常监控，首先要明白什么是异常，html、css这些东西，无非就是一个展示的问题，还不至于让页面白屏的事情发生，所谓的异常监控，其实就是js的异常监控。在前端领域，window.onerror是进行js异常的监听事件。并且要知道，它在IE中，是不支持的，所以IE的监控，要使用try catch 的方式进行捕获，比如我们可能还要注意到，遇到异步的时候，这个如何做try catch的异常捕获。
最后一个是前端sdk埋点，直接开发一个js文件，统计用户的UV/PV分析等等，比如用户的转化率之类的

```
45. 未来前端：考察价值
大屏技术：canvas、SVG、webGL、图表库、相关算法、图形学（GPU/显卡等）、动画交互

48. 构建前端体系、脑图
```
- 技术诞生的背景
- 技术原理
- 应用场景
- 横向比较同类技术的优缺点
- 未来支持的新特性
- 创新、可复制分享，解决一类问题的思维，能带人。
```

50. [vue 事件机制](https://juejin.im/post/6844903498174349320)
$emit触发事件，$on监听、once一次监听，自动off、$off、

51. vue 转小程序怎么实现(ast/生命周期对齐/跨平台模块兼容/兼容细节点实现过程)
完整模拟小程序生命周期、事件处理、组件规范等，比如 update 模拟 onshow，跳转时保留旧页面缓存 keep-alive & LRU 缓存算法，利用 storage 和过期时间设置维护缓存。
磨平样式差异，比如 fixed 元素遮挡，编译时根据 css 变量进行正确修正
组件按需打包 tree-shaking，路由按需加载

52. [设计模式](https://mp.weixin.qq.com/s/x3OCgS_knmM4D5zNSIVGRg) 

    - 设计模式在项目中的实现和实际应用
    - 观察者模式和发布-订阅模式的区别：在观察者模式中，观察者是知道 Subject 的，Subject 一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信，同时是异步的，比如消息队列。在发布订阅模式中，组件是松散耦合的，正好和观察者模式相反。
    - 观察者模式举例：我对企业很感兴趣（我作为观察者知道企业大名），企业维护我和其他面试者的简历，当职位空缺时主动通知我和其他竞争者
    - 单例设计模式
    - promise设计模式
    - 装饰器模式，可以增强原有组件的功能，并且不破坏它原有的特性

56. fetch
  - 千万不要过度设计
  - XHR 不符合关注点分离原则 SOC，req 和 res、监听被混在一个 xhr 实例中，在原有基础上革新会涉及技术债
  - 是否需要一个新的东西：旧方案仍然满足大部分需求，是否考虑了未来趋势以及一个现有议案的约束
  - fetch 使用最新的 Promise 语法结构，关注点分离，在 service worker 的应用中，fetch 能够自定义 response，而无需网络请求，结合 cache 则更加灵活强大。所以实际应用中 service worker 是请考虑 fetch。
  - xhr.send 建立在 fetch 之上
  - fetch API 对于某些 http 错误码 400、500 不会 reject
  - 缺少 progress events
  - xhr 库已经足够满足使用

57. 四象限分析法
- 业务重时怎么安排时间
- 优先做重要不紧急的事情：个人/团队规划、提效工具/平台建立、锻炼/个人影响力建立
- 事情是做不完的，只需要保证最重要的事情一直在被推进，不重要的可以讨论/推掉/改方案。
- 拆分任务，做好并行，在合理的区间中做任务调度。
- 建立自己的影响力和持续反思




59. [vue2.0 响应式原理](https://juejin.im/post/6844903597986037768)
辅助可略：https://www.yuque.com/shuai-u4smx/vue/gxbbmg

- view 变化触发 data 更新通过事件监听
- 以下是 data 触发 view 更新
- v2 中是递归遍历 data 中的所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter，在getter 中做数据依赖收集处理，在 setter 中 监听数据的变化，并通知订阅当前数据的地方

- 具体：
- 1.实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。
- 2.实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。
- 3.实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。
- 4.实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。


- 限制：
- 无法检测对象属性的添加与删除，需要配合 set/delete
- defineProperty 监听 array 是有缺陷的：改变 length 长度或者超出设置，监听都会失效。
- 性能问题，层级太深导致性能下降
- 所以 vue 在数组的原型方法上做了一些手脚 defineProperty(obj, 'push') 监听 push 方法

- 检测数组变化源码解析：
- 1.Object.create(arrayPrototype) 初始化一个以数组原型对象 Array.prototype 为参数的对象：Object.create(Array.prototype)
- 2.将该对象里的所有数组方法用 definePrototype 重写
- 3.在数据 observer 绑定的时候，判断数据对象是否有 __proto__，有就将数据直接绑定上重写后的原型
- 4.如果浏览器不支持 __proto__，依据原型链，就将重写的原型直接挂在数据上好了。
- 5.这样当调用数组 api 时，可以通知依赖更新，如果数组包含引用类型，继续递归遍历监控

- $set 原理：
- 如果目标是数组，直接使用数组的 splice 方法触发相应式
- 如果目标是对象，会先判读属性是否存在、对象是否是响应式
- 最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理，最后通知订阅 notify
 

- 总结：对象和数组都是通过递归遍历

60. v3 响应原理

- proxy 相比 defineproperty 能直接监听对象/数组（13 种），而不仅仅是属性，它返回新的对象，兼容缺陷。
- 借助 Proxy：get，set，deleteProperty，has（in），ownKeys（for...in） 这几个 handler 拦截操作，收集依赖
- 在属性添加或删除时 trigger 通知响应系统的更新，在reactive 和遍历循环时 track 跟踪收集依赖
	track 用来在读取时收集依赖。
	trigger 用来在更新时触发依赖
    深度观测：Vue3 对于响应式数据，不再像 Vue2 中那样递归对所有的子数据进行响应式定义了，而是再获取到深层数据的时候再去利用 reactive 进一步定义响应式，这对于大量数据的初始化场景来说收益会非常大

- 深度观测：typeof 判断 当前 Reflect.get 的返回值，如果是对象继续使用 reactive 做代理。
- ref 和 reactive 的区别：ref 相当于一个盒子，要调用需要 .value（将基础类型转成对象来调用，故要加 .value），reactive 其实就是一个 Proxy 代理。另外前者只能赋值简单类型，后者复杂。


- Proxy 其他用途：日志和校验，get+log 实现访问日志，set+typeof 校验
- 检测数组防止多次触发 get/set：用 hasOwnProperty 判断 key 是否为当前被代理对象的自身属性，或者与旧值比较，满足则执行 trigger




61. v8、webkit、jscore
- 浏览器内核分为两部分：渲染引擎（render engin）、js引擎(js engin)
- Chromium 基于 Webkit，衍生出 Blink，都是渲染引擎
- v8(chrome)/jscore(默认) 执行在 webview 的 webkit 渲染引擎中
- webview 的作用即用于手机系统来展示 html 界面的，webview 是 webkit 渲染引擎的一个组件
- JavaScript Runtime 用来执行JavaScript代码用的，为其提供了一个运行时环境，提供解释/编译、自动内存管理（GC）、对象模型、核心库等功能。
- v8 将 runtime 看成高级语言虚拟机，GC 等都在里面
- 渲染进程Renderer的主要线程：GUI渲染线程与JS引擎线程是互斥的，事件触发线程管理着事件队列，定时触发器线程，异步http请求线程


## rn 的编译解析过程是什么，如何把 js 编译为真正的 ios、android 应用。比如 flutter 的渲染机制，和 rn 这些渲染方式有什么不同，和普通的 web 网页又有什么区别
手机端使用 jscore 提供的 api 来驱动 rn
rn 与浏览器统一引擎，但使用自己的一套 UI 控件
JavaScriptCore 驱动 js + ReactJS 数据驱动编程 + Bridges 调用原生接口 就成了 React Native
通过平台定制 Bridges 翻译绘制指令给原生组件进行绘制
浏览器上，js 引擎直接驱动 js，驱动硬件的能力有限；rn 不同，rn 的原生代码驱动 js 引擎，引擎解析 js 并将结果返回给 native，比如绘制指令等，然后驱动所有可能的硬件.

rn 三线程：Shadow queue 计算布局类似线程池，UI 主线程，js 线程
rn 架构：java -> c++(处理java 与 js 的通信，含 jscore、Bridge) > js

Flutter 的编程语言是 Dart，所以执行时并不需要 Javascript 引擎
Flutter 可以直接操作 Skia 图形引擎进行绘制，图形性能媲美原生
Flutter UI 中的 Widget “数据化” ，然后通过 Engine 上的 Skia 直接绘制到屏幕上，这样的好处：不用管平台兼容性
Flutter 比起 ReactNative 少了一层 JavaScript Bridge，性能更佳
1.预先编译(AOT)，运行时直接执行Native(arm)代码
2.必需的同Native通信(channel)是C++层次，性能好

64. 惰性函数：兼容处理时要使用 if 分支，惰性函数返回选择好并重写后的原函数变量，或者 IIFE 赋值给函数表达式变量。

66 .Vue全家桶：mvvm实现的原理、vue-router（HASH路由实现的原理）、vuex原理、vue-cli（需要能够修改脚手架webpack配置项）
原本的路由是与后端交互，根据不同路径获取不同资源
spa 需求页面跳转也是不刷新的，于是产生前端路由
hash： /#/，hash 值的变化，并不会导致浏览器向服务器发出请求，只要监听 hashchange 即可
history 模式类似上面，但刷新页面时依旧会请求，所以需要服务器重定向
路由核心：更新视图但不重新请求页面
vue-router：封装已有 api 注册进 vue 实例，通过发布-订阅进行数据驱动

67. react全家桶：create-react-app（能够修改webpack的配置项）、react（掌握虚拟dom渲染原理、掌握dom-diff原理、掌握index索引对比机制、掌握mvc实现的原理）、react-dom/react-native、react-router、react-redux/dva/mobx（掌握原理，自己可以基于原生js写一套类似的插件、发现里面的不足）

68. 阿里超经典面试题
```
function Foo() {
	getName = function () {
		console.log(1)
	};
	return this;
}
Foo.getName = function () {
	console.log(2)
}
Foo.prototype.getName = function() {
	console.log(3)
}
var getName = function () {
	console.log(4)
} 
function getName () {
	console.log(5)
}
Foo.getName() // 2
getName() // 4 表达式在函数后面覆盖
Foo().getName() // 1
getName() // 1 上个覆盖了 getName
new Foo.getName() // 2
new Foo().getName() // 3 先实例化，后原型上的方法
new new Foo().getName() //  3 
```

69. 开发流程

UE 交互稿设计
ui 视觉设计
qa 测试
	产品提出需求，内部领导评审
    内部评审通过，拉上 RD、QA、UE 等评审需求、通过后开始详细设计
    评审这些设计比如 RD 的技术方案、UI 的视觉设计，其中技术评审往往会让我们对业务风险的把控、技术栈更清晰
    评审结束进行排期、QA 的排期根据 RD、FE的排期而定
    前后端分离开发配合 mock、联调自测
    code review
    提测 QA 各种环境的测试
    产品验收准备上线、准备上线计划：功能点，上线顺序，回滚计划等
    上线回测
    第 2 次验收，

## babel 原理
词法分析 tokenizer，将源代码分割成 token 数组，Token 中包含了语法片段、位置信息
语法分析 Parser，token 数组转成 AST
转换 (Transform)，遍历 AST，应用到 `访问者模式`，对节点进行增删改查，插件工作阶段：语法转换插件、代码压缩
生成 generator，转为字符串形式的源代码，附带可配置的 source map

访问者模式：babel 自己来遍历，对外提供节点操作的接口，响应式地维护节点关系，插件作为具体访问者定义想操作的节点及节点方法，当 babel 遍历到对应节点时即调用插件方法进行响应。
扩展：与 webpack 类似，都是微内核架构，大部分功能都靠插件扩展
预定义集合(@babel/presets-x) 方便管理和使用
presets 自动适配目标环境需要的 js 特性
polyfill 已经过时，源码直接引用了 corejs
@babel/plugin-transform-runtime，避免全局污染，避免重复定义声明 helper
```
{
  "presets": ["es2015", "react", "stage-2"] // 实验性或新的插件在前面
}
```


## [虚拟 DOM 的理解](https://mp.weixin.qq.com/s/zCGQEpEGJYQWMMvZfyUYHg)
- 从概念、优缺点，一个误解来说明
- 一种编程概念，ui 已一种理想的表现实行存储在内存中，并通过 dom 类库让其与真实的 dom 同步，即协调，可以让开发者减少部分心智，在不了解框架底层机制的情况下依旧能编写出具有良好性能的应用，当然里面的渲染原理又涉及到浏览器原理和 diff 等算法的优化...

- 本质上就是一个 dom 对象

- 传统 DOM API 细节太多，操作复杂，所以就很容易出现 Bug，而且代码难以维护。所以 react、vue 将底层细节隐藏起来，开发者只需要知道改变什么数据、生成的 ui 长什么样即可。
- 虚拟 dom + diff 并不是更快，而是声明式、数据驱动式地编程思想转变，算是一种开发的优化。
- 也由此，与单页面应用绑定
	1. 比如一个有序列表，想往中间插入一行，还需要查找插入的位置，vue 只需要更新整个数据，或者说是状态，不需要关心 dom 的操作细节。
    2. 整个列表刷新，这种方法简单粗暴，但问题就是慢，所以 `diff` 等算法应用而生。

- 用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；
- diff 算法 — 比较两棵虚拟 DOM 树的差异；
- patch 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。
- 优点：跨平台服务器渲染，无需手动操作 DOM，只需要写好view-model，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率。保证性能下限，必须适配转真正 dom 树的 API 操作
- 缺点：无法进行极致优化，需要保证性能下限
- 设计一个双向绑定


## [diff](https://juejin.im/post/6844904084374290446#heading-13)

- v2 diff：vnode 对象是树的递归遍历
	 - n^3：单个节点与旧 vnode 的依次比较，为 n^2，计算差异后遍历找到位置进行删除或增加 n，最终为 n^3
	 - diff 是什么，必要性（n3->n，同时减少回流和重绘），怎么触发
     		setter 触发通知，触发方式是将 watcher 加进异步更新队列，eventloop 会清空队列，watcher 尝试执行更新函数，调用渲染函数，重新计算 vdom，进行 diff

- 没有旧节点直接创建新的
- 新旧 vnode 不同，直接销毁旧的，创建新的

- 新旧 vnode 相同，继续比较子节点：
- 其中 vnode 为文本节点，与旧不同则直接更新
- 子节点依旧是新旧之间的比较，只有新节点直接创建，只有旧节点则删除旧的，新旧又不同，开始 diff 核心算法，重点讲解：
        - while 循环比较新旧子节点：头索引跟头比较，尾跟尾，比完缩减往中间收拢，比较遵从：
        - 头与头比较，相同则复用不作处理，同时头++，尾、头尾、尾头的目的都是为了复用
        - 用 key 比较
        - map 表遍历查找
        - 剩余节点，批量新增或删除
        - 总结：能不动就不动，不行就移动，最后处理新建或者删除。相比React的Diff算法，同样情况下可					以减少移动节点次数，减少不必要的性能损耗，更加的优雅
                
            
- v3 diff：

	- 1.vdom：创建 vdom 的时候多了个 dynamicChildren 动态节点，patch 的时候只比对动态
    	v2 静态节点也会 patch
    - 2.vdom：节点变更类型用 patchFlag 细分，用位掩码组合，作为判定更新的依据。
    	v2 如果是普通节点，会通过内置的update钩子全量进行新旧对比，然后更新；如果是component，则会在prepatch阶段进行判断，有变化则会重新触发forceUpdate。有很多无用的重复对比
    - 3.diff 核心变化：用数组 map 记录节点变更的位置以及新增的节点 + 最长子序列（如果递增则位置不变）
    - 4.相同事件缓存不会重新生成
    
        
- r16 diff：vnode 对象是链表的循环遍历，与递归不同的是可以设置暂停和恢复，根据调度展开的优化代码，首屏优化任务分片渲染 task-slice。
     - 复用没有变更的节点，用 key
	 - 先比较两棵树的根节点，若是不同的类型，则直接销毁旧的，重建新的。若是相同的类型，则看下 className、style 等是否相同，同时保留不变的状态，比较完继续对子节点递归，比如列表，在设置 key 的情况下 diff 的开销会更小 (没有key的情况下，在表头插入将会重建，表尾只会添加)



6. redux 状态管理和发布订阅模式有什么区别：考察数据的可预测和可回溯

## tcp 可以建立多少个连接，http 的管线化
HTTP/1.1允许多个http请求通过一个套接字同时被输出 ，而不用等待相应的响应。然后请求者就会等待各自的响应，这些响应是按照之前请求的顺序依次到达，管线化采用 FIFO
持久化 keep-alive 时使用，结果幂等时使用（get 请求）

12. AST 转换：考察词法分析和语法分析

  - webpack uglify-js 压缩原理，核心压缩规则
  - 扩展应用场景：编译器、IDE 格式化、babel、v8、eslint、uglify 细微差别
  - 压缩的坑

## React 的运行时 runtime
1.框架本身的代码会被打包进 bundle.js 运行在浏览器中，即  diff 等在运行时执行，这块代码直接导致
组件函数重新执行，造成重渲染 re-render，所以 react 设计时才放出哪些可以优化渲染的钩子让人为操作。
2.其实Virtual DOM高效是一个误解，vdom 高效是因为其不会直接操作原生 dom。但每次 state/props change 会重新执行 render()，调用 create 生成新的 vdom，然后进行新旧 vdom 的diff，得出需要更新的 dom 结果。这个过程是可能触发多次的，这很低效！
3.Fiber 这个架构解决的问题是不让组件的重渲染和reconcile的过程阻塞主线程的执行，但组件重渲染的问题依然存在
4.react 的解决：Pure 纯组件 和 memo，connect()，render() 里不要用箭头函数，总是产生新的引用，造成重渲染。
5.其他框架的解决：数据变化时直接更新对应 dom，Svelte会在代码编译的时候将每一个状态的改变转换为对应DOM节点的操作，从而在组件状态变化的时候快速高效地对DOM节点进行更新

## [权限组件怎么设计](https://zhuanlan.zhihu.com/p/99172614) ？
一切皆组件 + 接口的权限验证
给用户分配角色，角色对应一组权限，动态角色
权限控制粒度细分：组件和路由
用户登录时拿到开放的权限标识集合，路由变化前进行权限校验，决定是否渲染，进入页面后继续校验按钮级
v-if 是惰性的

## node 知识，服务端如何部署：pm2 -> docker -> openshift -> k8s

- docker/k8s 底层原理

隔离环境主要隔离什么环境：linux namespaces 的资源隔离
redis 如何做持久化
	RDB：在指定的时间间隔能对你的数据进行快照存储。
	AOF：记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据。
    
- docker ufs
- node 充分利用服务器多核：node cluster/k8s
- 应用层面如何监控 cpu/memory
- 如何查看一个 node 的服务端应用的内存和 CPU：ps/pidstat
- 当服务器的内存发生 OOM 问题如何排查：看 promethues，监控的高峰图表，日志，代码库变动
- 数据库 left join/right join 的区别
- 数据库索引中为什么要用 Btree：减少与磁盘的 IO 次数
- 聚簇索引
    
- 分布式锁：set key value EX 60 NX
- LUA


## [中间件的理解](https://segmentfault.com/a/1190000023787306) ？
复合函数的应用，桥梁，解耦

## 怎么保证后端服务稳定性，怎么做 [容灾](https://mp.weixin.qq.com/s/prf-mXexBh1Ie-ctq9FnzA)：多个服务器部署；降级处理，服务挂了，从缓存里面取， etc。



## 了解：flutter、webassembly、serverless、全链路监控

## mobx 与 redux 的区别，dva 和 redux 的区别
mobx 面向对象思想
redux 面向函数式


27. router 和 route 的区别
```
- route为当前router跳转对象里面可以获取name、path、query、params等
- router为VueRouter实例，想要导航到不同URL，则使用router.push方法
- history 实际采用了 HTML5 中提供的 API 来实现，主要有 history.pushState() 和 history.replaceState()
```

30. vue 优化
```
尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher
v-if和v-for不能连用，如果需要使用v-for给每项元素绑定事件时使用事件代理
SPA 页面采用keep-alive缓存组件在更多的情况下，使用v-if替代v-show
key保证唯一
使用路由懒加载、异步组件防抖、节流
第三方模块按需导入
长列表滚动到可视区域动态加载
图片懒加载
- v-if 是惰性的，初始 false 时不会加载，应用在切换频率低的场景
```

32. 灰度发布是大型项目在发布时的常见方法，指在发布版本时，初始情况下，只允许小比例（比如1~5%比例的用户使用），若出现问题时，可以快速回滚使用老版本，适用于主链路和访问量极大的页面，灰度发布的量级起码要千万以上


3. React hooks 原理及草案，vue3 的 hooks 原理
```
- 为什么 React 没有双向绑定、为什么 vue 没有 fiber 优化/ hook
- 框架的下一步发展
```

## 项目如何改进、重构
业务梳理，项目是否耦合，架构是否要变更，重构的优先级
技术、版本、维护、安全、用户交互性、性能优化
代码层面的组件化设计、状态管理，比如越发臃肿的 vuex 状态管理，比如增加适配层
vue3 composition api 实践

14. node 内存泄漏
```
- 意外的全局变量
- 遗忘的定时器
- 意外删除的 DOM 引用
- 闭包变量
- 未被回收的 dom 引用
- 循环引用，JSON.stringify 导致隐患
- [].length = 0 重置数组，不产生新的内存
```
15. 求下面代码的输出
```
function test(a,b) {
  console.log(b)
  return {
    test:function(c){
      return test(c,a);
    }
  };
}
var retA = test(0);  
retA.test(2);  // 0
retA.test(4);  // 0
retA.test(8);  // 0
var retB = test(0).test(2).test(4).test(8);
var retC = test('good').test('bad');  
retC.test('good');  
retC.test('bad');
```
## [Chrome Dev Tools 页面性能优化](https://mp.weixin.qq.com/s/azeUIx0EA86EFQrtIRUKwQ) ？

- [性能优化军规](https://juejin.im/post/6844903657318645767)

性能三大核心指标：
- LCP 实时更新的最大内容绘制，2.5s 算体验优秀，在用户交互后停止记录，大元素的快速载入让人体验良好
- FID 首次输入延迟，即首次交互响应时间，记录在 FCP 和 TTI(5s 内无长任务) 之间用户首次与页面交互时响应的延迟，小于 100ms 为佳。补充：因为 idle 内假如有超过 50ms 的长任务，待页面响应会给人一种延迟感，综合考虑为 100ms。
- CLS Cumulative Layout Shift）累计位移偏移，记录了页面上非预期的位移波动，位移距离 × 位移影响的面积 < 0.1 体验优秀，反例：小屏手机上突然插入 dom 或广告
- [针对指标的性能优化](https://juejin.im/post/6850037270729359367#heading-3) 背诵最后一段

- TS 和 codereview 也是优化，增加代码可读性和可维护性
- 白屏可能的原因：js 文件加载顺序出错，比如业务 js 在依赖之前导致报错依赖变量没有定义
- 解决 ios webview 首屏骨架屏无效的问题：在骨架屏展示后再通过监听 onload 动态引入 cssjs，解决了白屏、弱网骨架展示
- 楼层懒加载，资源预加载，按需加载插件、组件，babel 实现 polyfill 的按需加载
- 其他优化：
  1.mock 内嵌脚手架中，请求拦截读取本地 json，待后端 API 能够使用后可以更新 json 文件
  2.SSI 技术，请求服务器引入动态组件，常用于动态维护公共组件，使用 ssi-loader 加载器

17. [CI/CD](https://mp.weixin.qq.com/s/MbeW8UNZ1fPekWcaNqmsCQ)

## [SSR](https://zhuanlan.zhihu.com/p/35871344)
```
- 坑1：cpu/memory 可能爆了，出现异常不好定位调试，TTFB 读取页面第一个字节的时间- 加载慢了（如果不加缓存或者骨架屏，就会导致白屏），开发复杂
- 缺2：需要处于 nodejs server 环境，更多的服务器负载，做好缓存策略
- 异常：window is not defined/样式报错 @ 则需要 css-loader、style-loader、替换 lib 编译包
- 总结：结合你的项目具体进行相关指标的评估，切勿跟风，为 SSR 而 SSR
- 原理：拼接 html 字符串，在 innerHTML 中展示
```
19. 手写深拷贝：考察类型考虑/Symbol/Date等的构造/循环优化/共用引用
20. 手写防抖节流
- [1](https://www.cnblogs.com/LuckyWinty/p/5949970.html#4564734)
- [2](https://mp.weixin.qq.com/s/M7KBX3w2KqlWhZFHJSYP6Q)
- 防抖+图片懒加载：delay 时间内图片是缺失的。
- 节流2.0+图懒：比较完美

## 微服务/微前端的理解 ？
- [1](https://mp.weixin.qq.com/s/HVwcY8JGyrK8VcN1Ic9sWQ)
- 微服务和微前端
- 不同技术栈、框架的项目，对接不同团队、独立部署互不影响

## node 大量日志怎么处理的：考察缓冲队列、秒杀、抢票 ？
[1](https://juejin.im/post/6844904003151593479#heading-34)

## 大数据处理
web worker 通过 SharedArrayBuffer 共享内存(百万级使用)
分而治之，算法优化，内存及时回收
虚拟列表只在可视区域渲染
ArrayBuffer 数组内存空间连续查找更快
[factory 模式优化内存](https://zhuanlan.zhihu.com/p/27882908) 以后理解！

```
while(length) {
	length.splice
    let res = await api...
    res.data.reduce(fn, init)
}
```

24. websocket：服务器与客户端都能主动推送。
```
- 只需要一次握手就能通信
- 协议标识符 ws/wss
- 没有同源限制
- http 101 升协议
```
25. shelljs 基于 node 的命令封装插件，shell 与 `自动化` 强相关
```
- 替换文件内容 sed/cut
- 格式化文本信息 awk，以文件的一行为处理单位
```

## CDN：增加用户访问速度，降低网络延迟，带宽优化，减少服务器负载，增强对攻击的抵抗能力

1. [FCP/FMP/FP 分别是怎样定义，如何统计](https://mp.weixin.qq.com/s/wDKKj5R8SYm-_75Zn1y30A)

## ng 负载均衡的方式
增加吞吐量、加强网络数据处理能力、提高网络的灵活性的方法
简言之，负载均衡实际上就是将大量请求进行分布式处理的策略
Nginx 作为一个基于 C 实现的高性能 Web 服务器，高并发、高扩展、可靠且开源
算法：轮询处理性能相近的集群，加权轮询处理则分配权重优先级，IP hash 解决 session 不共享的问题，映射到同服务器，场景：分片上传。
容灾：IP hash 的缺点：假如当前 session 挂了怎么办，灰度发布到别的机器。

4. es6 静态分析原理其实就是 AST
所谓的静态分析, 就是在不运行代码的情况下, 编译时对代码进行检测扫描分析，比如没被使用或引用的的变量/模块会被删除
import 会被提到文件顶部，优先于模块内的其他内容执行，值的拷贝？
模块不会重复执行，加载时会被缓存
静态分析扩展：动态 import API，自带 promise，运行时动态引入 es6 模块
tree-shaking 的原理也是基于静态分析

5. 有一个很大很大的文件，如何统计文件里面重复最多的行是哪行(参考git的记录存储)

## 组件设计
单一职责：要么负责传递数据给子组件，要么负责数据渲染，`不能即传递，又展示`。
避免深层嵌套，避免数据层层透传，而应该使用组件透传(控制反转)
比如 vue 的 slot，react 的 children，即控制反转
[数据依赖注入 Context provide/inject & 组件透传的控制反转](https://zh-hans.reactjs.org/docs/context.html)
缺点：context 使不同层级的组件能访问同一份数据，会使复用性变差；而组件透传会使高层组件变得更复杂
[严格遵守组件化](https://juejin.im/post/6844903925053652999#heading-5)：组件化以适应需求的更改

## js 延迟加载
head 中：async 异步下载，同步执行，会阻塞；defer 异步下载，页面解析完毕、DOMContentLoaded 前执行（现实中不一定）
body 末尾

## 模块化开发演进：函数 -> 对象 -> 立即执行函数的写法
通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染

## VUE 给对象新增属性，页面没有反应
- 组件初始化时会对 data 执行 g/s 转化，新属性不在 data 中所以不会自动响应更新
- mounted(){ this.$set(this.obj, 'sex', 'man')} // mounted 声明周期 $el 初始化完毕

## VUE 相关
- 监听子组件生命周期使用 @hook:mounted
- v-show 适合频繁切换
- key+diff：高效更新虚拟 dom，key 的改变也会触发过渡
- keep alive：缓存组件不卸载，使用 LRU 算法，least recently used，四个关键字段为 ...include, ...actived, 维护 max 缓存大小
- $parent / $children 访问父子实例
- $attrs/$listeners 隔代组件通信
- $on, $off, $emit, $once 其实就是发布订阅模式 
- vue-router 3 种 ：
    mode：hash（location.hash/hashChange事件监听） -> 
    history （history.pushState/replaceState/popstate事件，需要服务器配置兜底，404/index.html） -> 
    abstract （兜底兼容所有 js 环境）
- vuex：mutation 唯一更改 state 中状态的方法，action 提交 mutation
  
- 为什么 Vue3 不需要时间切片：[Why remove time slicing from vue3]
	利用宏任务队列，以 16ms 分批调度组件函数并操作 dom
	vue 现在的实现，由于调度的基本单位是组件，所以它仍然会因为组件内部的逻辑而被阻断，时间分片收益不大
    尤大：除了高帧率动画，其他的场景几乎都可以使用防抖和节流去提高响应性能
    时间分片要体先在细粒度上比如首页优化！
- Vue3 的composition-api到底好在哪：[Amendment proposal to Function-based Component API]
	setup
    代码维护、逻辑复用，一张分块图
    基本类型用包装对象来实现，为了更好的响应式。模块函数可以以参数的形式传递。
    .value 调用不仅有利于响应式还具备 TypeScript 类型推导等优势
    依赖注入 provide/inject

## 移动端布局方案看场景
rem 和 vw 适合视觉设计对元素位置有较强依赖：美团、小红书、b 站
问题：兼容和奇葩 dpr 的设备问题，需要计算
1px 变 2px， 又被 initial-scale=0.5 缩小了一半
px 结合 flex 等布局方式沉浸文本内容：知乎、新闻

## intersection Observer
统计广告/图片懒加载/无限下拉/视频离开视窗时停止播放

## 移动端视口 `<meta name='viewport' content='...'>`
width=device-width 布局视口 = 理想视口
initail-scale=1 视觉视口 = 理想视口（请按实际来设置）

## 前端登录

- cookie+session 隐患：服务器集群同步登录态、csrf 攻击
- token+refreshToken：假如使用 JWT 生成，隐患颇多，占用太大，并且可能遭受 xss 攻击
- SSO 单点登录：认证中心校验授权码 ticket，并将访问网站和认证中心的登录信息一同写入 cookie
-Oauth 第三方认证授权：比如某应用需要读取 google 的照片，使用 google 账号授权登录。用户从 google 获取登录令牌，这个令牌的权限和作用范围并不是无限的，由用户或授权方决定。具体：从 google 应用拿到临时票据，配合申请的 appid、appsecret 等，向 google 服务器申请 token
- 小程序安全原因：指定域名、https、登录凭证有效性只有 1 次，小程序双线程中渲染层和逻辑层分离，dom 无法直接在 渲染层操作，也不支持动态加载脚本，避免 xss
- 身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听，并且轻量无状态

## 9 种跨域
- 同源策略：浏览器核心安全功能 协议+域名+端口 完全相同，避免 CSRF、XSS 的攻击
- 限制内容: 浏览器存储、DOM 节点、Ajax 拦截
- 允许跨域资源：img_src、link_href、script_src
- 如果是协议和端口造成的跨域问题，前台是无能为力的
- 正向代理用途：实现跨域
- 反向代理：场景实现跨域或为服务器集群提供负载均衡
- 1.JSONP：xss 攻击
- 2.CORS：简单请求和复杂请求（预检 option）
- 3.postMessage 跨窗口，跨 iframe
- 4.websocket 持久化协议，全双工通信，主动发送和接收，建立时需要借助 HTTP 协议，建立好后双向通信就与 HTTP 无关了
- 5.Node 中间件代理：两次跨域，开发利器，服务器之间的请求'转发'无需遵循同源策略
- 6.nginx 反向代理：最简单的跨域（nginx 用途：静态资源，代理转发，负载均衡）
- 7.window.name + iframe：利用 name 值在不同域加载后依旧存在，通过 iframe 的 src 属性由外域转向本地域，同时跨域数据 window.name 也传递到本地域，操作需要：2 同域+1 外域。
- 8.location.hash + iframe：类似7，hash 在 url 上
- 9.document.domain + iframe：通过 js 设置 document.domain 为相同主域。
- 总结：CORS 是根本解决方案，推荐。代理主要通过同源策略对服务器的不加限制，日常生活中就用这两种够了

- 一句话概括正向代理，反向代理： 正向代理客户端， 反向代理服务端

11. OSI 7 层框架
```
- 应用层
- 表示层
- 会话层
- 传输层
- 网路层
- 数据链路层
- 物理层
```

## 批量更新
- 将一段时间内对 model 的修改批量更新到 view 的机制：setState.callback，$nextTick 的回调等。
- 换句话说：视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新

## setState 和 fiber
- React 引发的事件处理比如 onClick，会触发一个批量更新的状态 isbatchingUpdates，当为 true 时会将 model 放到队列中，一次统一执行，这直接导致 `合成事件` 和钩子函数的调用顺序在更新之前，拿不到更新之后的数据。需要注意的是，这里的异步其实还是同步，但你可以认为是异步的。
- 先 diff，判断是否有改变，然后 diff dom 判断是否要更新视图
- setState 回调函数可以确认已更新
- 何时同步：只要不是事件处理还有异步调用，比如定时器之类的就能同步，isbatchingUpdates 默认为 false
- React的每个生命周期和合成事件都处在一个大的事务当中。在事务的前置钩子中调用batchedUpdates方法修改isBatchingUpdates变量为true，在后置钩子中将变量置为false。原生绑定事件和setTimeout异步的函数没有进入到React的事务当中，或者当他们执行时，刚刚的事务已近结束了，后置钩子触发了，所以此时的setState会直接进入非批量更新模式，表现在我们看来成为了同步 setState

- why fiber：从setState开始到渲染完成整个过程是同步的，如果需要渲染的组件比较庞大，js执行会占据主线程时间较长，会导致页面响应度变差，比如动画、交互卡顿。
- fiber how：同步适用于函数，而 UI 的场景稍稍复杂，我们需要优化改变，fiber 的调度就是用来约束 js 何时需要干什么，任务分优先级，每次只做一个小任务，


16. r16 生命周期
```
- 计划废弃：componentWillMount、componentWillReceiveProps 使用不当会陷入渲染死循环、componentWillUpdate
- 替代：static getDerivedStateFromProps、getSnapshotBeforeUpdate
- 原因：
- 1. 用户往往担心页面加载完毕时，更新其他组件 state 已经太晚。事实并非如此，React 可确保在用户看到更新的 UI 之前，刷新 Did 期间发生的任何 setState 调用。
- 2. Will 外部回调可能会在一次更新中被多次调用，相反， Did 只会调用一次。
- 3. 派生 state 顾名思义，作用：缓存或其他，不推荐，有别的替代方案，比如缓存过滤需要对比前后变化，推荐 PureComponent（useMemo），只有数据变化或父级重新渲染才会被调用，不了解的话可能会导致一些性能浪费
```

17. 事件通讯插件全对比：vuex、redux、mobx、flux、redux-saga 等
18. hook 钩子
| 钩子名      | 作用                              |
|-------------|-----------------------------------|
| useEffect   | 监听useState定义值的变化          |
| useContext  | 定义一个全局的对象                |
| useReducer  | 可以增强函数提供类似 Redux 的功能 |
| useMemo     | 在依赖变量改变时执行，返回缓存值  |
| useCallback | 在依赖变量改变时执行，返回缓存fn  |



> vue 3.0 & r16

1. v3
```
1.v3 重写了 vdom，性能提高 1~2 倍，ssr 提高 2~3 倍
2.v3 支持 tree-shaking
3.babel 编译的代码经过 uglifyjs 的 tree-shaking 因为函数副作用（IIFE、原型属性等影响）的原因无法真正消除所有无用的代码，而 rollup 却可以，因为它们做了程序流分析。另外静态 import 有利于 t-shaking
4.v3 Composition API 类似于 React Hooks：优势按着逻辑编程
5.v3 对象式的组件声明方式，可以更好的 TS 支持，自定义渲染器 vugel
6.definePropterty() 实现的数据绑定无法实现数据对象新增属性值的变化，且vue中的数组方法也是自己 polyfill实现的
7.作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提高了性能
8.监测机制改进了 defineProperty 的不足，另外支持 Map、Set、WeakMap 和 WeakSet
```

重点为 3 和 4：[hook 对比](https://blog.csdn.net/tonylua/article/details/103311090)


```
1. composition api 的设计动机：复杂组件越来越难以维护，需要上下反复横跳……开发者更倾向于通过逻辑考虑来组织代码
2. react 逻辑复用：mixin -> hoc/render props -> hook
2+ vue 逻辑复用：mixin + slot -> composition API
2+ mixin 本身是没有问题的，但太依赖使用者，mixin 本身是为了减少重复代码，隐藏累赘和复杂逻辑，但是对于大工程协作是有一定风险的：注入多个 mixin 可能造成命名冲突，依赖冲突，来源混乱，边界侵蚀。
vue 使用 mixin 我个人观点是它主打的就是易上手，自由灵活。
2+ hoc：将组件作为参数或返回一个组件的组件：页面复用、权限控制（渲染劫持）、性能追踪、日志打点
2+ hoc 还是逃不了组件嵌套和大量的 props 参数引用，render props 来源不明确，自定义 hook 则清晰明了
3. v2 将逻辑分布在各个 option 中，单组件越发复杂，则越难重新理清和维护。
3+ v3 使用 setup+swr hook+缓存更新，删除重复数据 使逻辑更加聚合轻量
3+ v3 cpsition 的缺点：没有 this，却多了个 包装对象 ref，作为响应数据的变量传递，与原有 dom ref 有点混淆。
```

2. v3 与 r16 区别和相似
```
diff
- v3 setup(props) 在 beforeCreate 之前
- v3 setup(props) props 不能解构，形如 setup({name}) 这样是错误的，会造成 watch 无法更新响应
- r16 hook 函数最顶层使用，保证顺序
- v3 组件选项 setup 声明周期内只被调用一次，取名就能看出来，初始化并收集依赖，数据更新就会执行依赖
- r16 hook 实际每次渲染还是执行整个函数，本质上编译方法还是 React.createElement，按顺序存储 fiber 链表，每次渲染都是按顺序取节点，所以禁止条件调用；
- r16 每次渲染，useEffect 都会重新执行并产生闭包，性能和 GC 压力上逊于 v
- r16 监听数据时，useEffect 的第二项 [] deps 会进行前后两次渲染的浅对比 Object.is
- r16 hook 闭包陷阱：假如忘记传递正确的依赖项数组，useEffect、useMemo 可能会捕获过时的变量
- v3 setup(props) computed watchEffect 自动跟踪依赖
- 响应的不同

similar
- Suspense：v3 的 Suspense 异步嵌套比 r16 更加轻量，r16 还在完善中
- 自定义 hook：逻辑重用，不用反复横跳，返回的值自定义不用担心命名冲突……
- 创建响应式数据：v3 的 ref，r16 的 useState

总结
- r16 本身富有创造力，我们需要自己设计顺序、渲染优化
- v3 的 hook 灵感来源于 r16，同时响应式模式恰好解决了 r16 的问题：hook api 执行顺序、优化、追踪、闭包
- v3 抄袭：v3 相比 r16 有相似之处，更有超越的地方。框架本身就是给人用的，易上手也是其中重要的前提。react-router 也有借鉴 vue-router……
```

3. super() // React.Component.prototype.constructor.call(this)
4. 编译原理 SICP、计算的本质、编译器设计
5. 前端的方向：跨端、可视化、serverless（让前端开发自治，运维自驱）、微服务
6. 为什么是前端：前端一直希望能够有机会摆脱资源的困境，对整体工种的职能、边界有更广泛而清晰的拓展需求，造就了如今前端的范围不断衍生，从端侧到智能化，无一不是职能扩大的体现

## [浏览器原理](https://zhuanlan.zhihu.com/p/96986818)  以后复习

> `项目/架构/工程化`

1. 前端工程化
```
- 微前端
- 工程师概念：不是论证某种实现方式可行就完了，而是到底怎么合成，按照什么路径方式能实现，哪种方式最快最省力，这个过程的可能性才是工程师的任务。
```

2. 中台
```
- 将重复的业务比如支付、用户、搜索、开发工具、数据分析等组织起来，为前后台提供一个公共资源，即中台。
- 1.技术中台：MQ、分布式缓存、容器等
- 2.业务中台
- 3.数据中台：人物画像、日志分析、数据建模
- 4.算法中台：搜索、语音图像、人机对象、过滤等
- 微服务分层架构之 BFF ：多端对接口的需求是多变的，后端向微服务演化，接口趋向原子化、功能更加单一和通用，由此引出 graphGl、nodejs 实现 BFF 对接口进行聚合裁剪解决单一需求需要引用多个接口的繁琐和种种缺点，交由前端来自定义
- BFF 的缺点：前端需要维护多端的接口，需要关注并发。
- BFF 基于 serverless：serverless 让后端更后，解决 BFF 的缺点，精简开发流程，不需要运维，前端只要编写函数即可 Faas。
- serverless 无服务器架构
- 并不是真的无服务器，这些服务器的管理由云计算平台提供，对于用户侧无须关注服务器配置、监控、资源状态等，可以将重点放在业务逻辑上
- serverless 场景：小程序云开发，云监控，SSR...
- serverless 多进行单元测试，尽量少的集成测试：将业务逻辑和函数依赖的 Faas 和 Baas 分离
- serverless 冷启动（环境启动）：node/python 速度是 java 等的 100 倍
- serverless：less is more
- FaaS 是 Serverless 架构的其中一种形态，函数即服务
- FaaS 只是其中的一小部分，基于事件驱动的模型，从微服务（MicroService）这种专注于单一职责与功能的小型功能块演进而来。如今这种更加“代码碎片化”的软件架构范式，相比微服务更加细小的程序单元，给业务代码提供了无与伦比的灵活性
- 典型服务器仅提供 5%～15% 的平均最大处理能力的输出，即 cpu 利用率极小，这无疑是一种资源的巨大浪费。而随着 Serverless 架构的出现，让服务提供商提供我们的计算能力最大限度满足实时需求，这将使我们能更有效地利用计算资源
- 传统应用开发的劣势正是函数开发的优势
- 通过 node 编写启动器，serverless 可以移除底层容器和协议的差异性，实现软件版本快速更新
- 后端往大后台下沉，前端往小前台发力，提升生产力
- 我个人的理解：这正是未来智能化的趋势，像小说里一样。
- 缺点：初始还需要前后端能力者编写，现世不久，其实只有大厂应用，还需要足够时间的稳定测试与验证，新的研发流程还需要沉淀和探索。
- 3块：快速交付试错，容器快速调度，代码快速启动。
- 可以快速搭建非核心的外围衍生业务模式，暴露标准化的接口范式，一方面可以及时响应前端多变的需求，另一方面提供标准化、一致化的接口范式，也可以降低沟通成本、提高开发效率。基于此, 前端也可以沉淀自己的可复用的业务组件。

```

3. 技术栈和架构
```
- 约束大于规范：如果没有约束机制，规范永远是规范
- 避免'单点故障'：交叉 code review，参与熟悉不同项目，避免人员请假/离职造成的项目凝滞。
- 推动协作效率，集体利益大于个人利益，降低风险。
- 尝试去理解业务，理解商业和世界运作的规律，提升格局和软技能
- 要分清基础设施和架构的区别，做基础设施还是创新能力建设，一定要看长远的利益
```


5. 前端容灾
```
- 后端容灾：通过 nginx 等均衡负载集群拦截分发，将挂掉的屏蔽，通过算法将请求转给性能和资源更多的服务器集群，做到集群高可用。
- 前端容灾：针对后端接口挂了的情况下页面依旧完好运行。
- 1.localStorage：将成功返回的数据以 key: value 的形式存储起来，下次请求失败直接使用
- 2.备注一份静态数据到 CDN 兜底
- 3.利用 Service worker 的 caches API 做页面接口缓存，甚至可以离线缓存整个页面

- service worker 后台独立于网页运行的脚本：纯粹的脚本运行不与用户交互，没有 dom 权限，能推送通知和同步，拦截和处理 fetch 网络请求，最棒的是支持离线体验。
- Service worker 是浏览器和网络间的代理。通过拦截文档中发出的请求，service worker 可以直接使用缓存中的数据，达到离线运行的目的
- Web worker 让我们减轻主线程中的密集处理工作的脚本，可以在不干扰用户界面的情况下执行任务
- Web worker postMessage/on... 缺点：但与主线程交互时仍受到主线程单线程的瓶颈制约，假如频繁与主线程交互还是会阻塞。
- Web worker：通常用于数据处理，比如 canvas 绘制、流媒体数据处理、加载外部脚本等
- js 单线程是怕多个线程同时操作 dom，一个在dom上添加内容一个删除dom，听谁的，虽然 web worder 可以利用多核资源，但是依旧限制了不能操作 dom
```

## 监控和埋点
- 线上项目，需要统计产品的用户行为和使用情况，从多角度了解用户群体，从而升级迭代产品，使其更加贴近用户。
- 监控分类：
- 1.用户行为通过前端数据监控：PV / UV、页面停留时间（广告投放）、页面入口（营销推广）、用户交互行为
- 2.性能监控包括首屏加载时间，白屏时间，页面渲染时间，请求和响应时间、动画等
- 3.异常监控包括脚本执行报错等
- 步骤：埋点 -> 上报 -> 数据处理、分析
- 方案：代码埋点、可视化埋点（不能手动定制）、无痕埋点（全埋点、事件绑定、定期上传解析，转为可视化报告）
- 具体场景：
- 1.进入页面：上报用户机型等访问信息、入口来源、PV/UV、首屏
- 2.用户交互：上报触发的事件类型、请求响应时间
- 3.页面异常：捕获 try catch
- 根据各方案缺点来定制：灵活同时减小上传压力就用代码埋点
- 上报周期根据数据量：数据少则时时上报，多则缓存定期上报
- 数据格式：who（appid，userAgent）/when（timestamp）/where（url，type，el）/what
- 数据加密 openSSL，使用 node crypto

## 4种连接之长连接：实现方式隐藏 iframe，不需要客户端发送请求，服务端有数据就会马上发送给客户端

## golang 的 gc ？

## golang 与 java 的区别
go 是静态编译的语言，可在不同平台交叉编译；java 也是，附带动态特性，有一层 jvm，可以跨平台直接运行
静态编译：不依赖动态链接库，可以任意部署到各种运行环境，就是体积大一点
go 高并发：Go 利用 goroutines 代替了线程，它可以通过多核并发计算能大幅度提高程序的性能，但是 Golang 的协程如果使用不当反而会成为影响程序执行的瓶颈，它的各种浪费特性使 Go 变得非常突出
Go 提供垃圾回收，但是像 Java 一样，它不支持完整的 GC
golang 语言简单，函数可以返回多个值，通常会带上一个 err。
编译过程一般分为 6 步：扫描、语法分析、语义分析、源代码优化、代码生成、目标代码优化。

## redis 的优点和应用场景
支持 k-v，list，set，hash 等，实时的数据备份，内存读取，当然也可以持久化在磁盘上。
场景：使用内存提供存储，通过持久化保存，且针对 request 是单线程操作。
查找最新的回复、排行使用 ZRank、自动删除过期数据

## TS: type vs interface
两者都能定义对象或者函数，也能 extends 扩展对方
type 可以声明基本类型别名 `type Name = string`，联合类型 |，元组 [] 等类型，但 interface 不行
interface 能够声明合并，能被 implements 实现多个接口
优先级 interface 先用